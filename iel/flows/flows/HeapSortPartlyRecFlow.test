package com.template.flows;

import co.paralleluniverse.fibers.Suspendable;
import com.template.contracts.HeapSortPartlyRecContract;
import com.template.states.HeapSortPartlyRecState;
import net.corda.core.contracts.Command;
import net.corda.core.flows.*;
import net.corda.core.identity.Party;
import net.corda.core.transactions.SignedTransaction;
import net.corda.core.transactions.TransactionBuilder;
import net.corda.core.utilities.ProgressTracker;

import java.security.PublicKey;
import java.util.ArrayList;
import java.util.List;

@InitiatingFlow
@StartableByRPC
public class HeapSortPartlyRecFlow extends FlowLogic<Void> {

    private static final int k = 2; // 2, 3

    private final String[] args;
    private final String function;
    private Party notary;
    private List<Party> counterParties;

    private final ProgressTracker.Step sort;
    private final ProgressTracker progressTracker;

    @Override
    public ProgressTracker getProgressTracker() {
        return this.progressTracker;
    }

    public HeapSortPartlyRecFlow(final String functionConstructor, final List<String> args,
                                 final Party notaryConstructor,
                                 final List<Party> counterPartiesConstructor) {

        if (notaryConstructor != null) {
            notary = notaryConstructor;
        }
        if (counterPartiesConstructor != null) {
            counterParties = counterPartiesConstructor;
        }

        function = functionConstructor;

        this.args = args.toArray(new String[0]);

        String signature = this.args[this.args.length - 1];

        sort = new ProgressTracker.Step("sort/heapSortPartlyRec " + signature);
        progressTracker = new ProgressTracker(sort);
    }

    @Suspendable
    private void heapSortPartlyRec(int[] A, int l, int r) throws FlowException {

        buildheap(A, l, r);
        heapsort2(A, l, r);

        TransactionBuilder txBuilder = new TransactionBuilder(notary);

        HeapSortPartlyRecState outputState = new HeapSortPartlyRecState(getOurIdentity(), counterParties);
        txBuilder.addOutputState(outputState);
        List<PublicKey> requiredSigners = new ArrayList<>();
        counterParties.forEach(party -> requiredSigners.add(party.getOwningKey()));
        Command<HeapSortPartlyRecContract.Dummy> command = new Command<>(new HeapSortPartlyRecContract.Dummy(),
                requiredSigners);
        txBuilder.addCommand(command);

        SignedTransaction signedTx = getServiceHub().signInitialTransaction(txBuilder);
        List<FlowSession> sessionList = new ArrayList<>();
        counterParties.forEach(party -> sessionList.add(initiateFlow(party)));

        SignedTransaction fullySignedTx;
        try {
            fullySignedTx = subFlow(new CollectSignaturesFlow(
                    signedTx, sessionList, CollectSignaturesFlow.tracker()));
            subFlow(new FinalityFlow(fullySignedTx, sessionList));
        } catch (FlowException ex) {
            getLogger().error("Error while handling flow " + ex.getMessage());
            throw new FlowException("Error while handling flow " + this.getRunId() + " " + ex.getMessage());
        }

        progressTracker.setCurrentStep(sort);
    }

    private void heapsort2(int[] A, int l, int r) {
        if (r > l) {
            exchange(A, l, r);
            heapify(A, l, l, r - 1);
            heapsort2(A, l, r - 1);
        }
    }

    private void buildheap(int[] A, int l, int r) {
        buildheap_helper(A, l, r, (r - l - 1) / k);
    }

    private void buildheap_helper(int[] A, int l, int r, int i) {
        if (i >= 0) {
            heapify(A, l, l + i, r);
            buildheap_helper(A, l, r, i - 1);
        }
    }

    private void heapify(int[] A, int l, int q, int r) {
        int largest = l + k * (q - l) + 1;
        if (largest <= r) {

            for (int i = largest + 1; i <= largest + k - 1; i++) {
                if (i <= r && A[i] > A[largest]) {
                    largest = i;
                }

                if (A[largest] > A[q]) {
                    exchange(A, largest, q);
                    heapify(A, l, largest, r);
                }
            }
        }
    }


    private void exchange(final int[] A, final int q, final int i) {
        int tmp = A[q];
        A[q] = A[i];
        A[i] = tmp;
    }

    @Suspendable
    @Override
    public Void call() throws FlowException {
        if ("Sort".equals(function)) {

            if (args.length < 4) {
                throw new FlowException("Call to Sort must have at least 4 parameters");
            }

            int[] A = new int[args.length - 3];

            for (int i = 0; i < A.length; i++) {
                A[i] = Integer.parseInt(args[i]);
            }

            int l = Integer.parseInt(args[A.length]);
            int r = Integer.parseInt(args[A.length + 1]);

            heapSortPartlyRec(A, l, r);
            return null;
        }

        throw new FlowException("Not yet implemented function called");

    }
}