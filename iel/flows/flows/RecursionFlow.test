package com.template.flows;

import co.paralleluniverse.fibers.Suspendable;
import com.template.contracts.RecursionContract;
import com.template.states.RecursionState;
import net.corda.core.contracts.Command;
import net.corda.core.flows.*;
import net.corda.core.identity.Party;
import net.corda.core.transactions.SignedTransaction;
import net.corda.core.transactions.TransactionBuilder;
import net.corda.core.utilities.ProgressTracker;

import java.security.PublicKey;
import java.util.ArrayList;
import java.util.List;

@InitiatingFlow
@StartableByRPC
public class RecursionFlow extends FlowLogic<Void> {

    private final String[] args;
    private final String function;
    private Party notary;
    private List<Party> counterParties;

    private final ProgressTracker.Step recursion;
    private final ProgressTracker progressTracker;

    @Override
    public ProgressTracker getProgressTracker() {
        return this.progressTracker;
    }

    public RecursionFlow(final String functionConstructor, final List<String> args, final Party notaryConstructor,
                         final List<Party> counterPartiesConstructor) {

        if (notaryConstructor != null) {
            notary = notaryConstructor;
        }
        if (counterPartiesConstructor != null) {
            counterParties = counterPartiesConstructor;
        }

        function = functionConstructor;

        this.args = args.toArray(new String[0]);

        String signature = this.args[2];

        recursion = new ProgressTracker.Step("recursion " + signature);
        progressTracker = new ProgressTracker(recursion);
    }

    @Suspendable
    private void recursion(int start, int end) throws FlowException {

        if (start != end) {
            recursion(start, end - 1);
        }

    }

    @Suspendable
    @Override
    public Void call() throws FlowException {

        if ("Recursion".equals(function)) {

            if (args.length != 3) {
                throw new FlowException("Call to Recursion must have 3 parameters");
            }

            int start = Integer.parseInt(args[0]);
            int end = Integer.parseInt(args[1]);

            recursion(start, end);

                    TransactionBuilder txBuilder = new TransactionBuilder(notary);

                    RecursionState outputState = new RecursionState(getOurIdentity(), counterParties);
                    txBuilder.addOutputState(outputState);
                    List<PublicKey> requiredSigners = new ArrayList<>();
                    counterParties.forEach(party -> requiredSigners.add(party.getOwningKey()));
                    Command<RecursionContract.Dummy> command = new Command<>(new RecursionContract.Dummy(), requiredSigners);
                    txBuilder.addCommand(command);

                    SignedTransaction signedTx = getServiceHub().signInitialTransaction(txBuilder);
                    List<FlowSession> sessionList = new ArrayList<>();
                    counterParties.forEach(party -> sessionList.add(initiateFlow(party)));

                    SignedTransaction fullySignedTx;
                    try {
                        fullySignedTx = subFlow(new CollectSignaturesFlow(
                                signedTx, sessionList, CollectSignaturesFlow.tracker()));
                        subFlow(new FinalityFlow(fullySignedTx, sessionList));
                    } catch (FlowException ex) {
                        getLogger().error("Error while handling flow " + ex.getMessage());
                        throw new FlowException("Error while handling flow " + this.getRunId() + " " + ex.getMessage());
                    }

                    progressTracker.setCurrentStep(recursion);

            return null;
        }

        throw new FlowException("Not yet implemented function called");

    }
}